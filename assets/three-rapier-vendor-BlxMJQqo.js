import{_ as mt}from"./react-three-drei-vendor-CbfeVupl.js";import{ColliderDesc as pt,ActiveEvents as Se,RigidBodyDesc as gt,Vector3 as Le,EventQueue as yt}from"./dimforge-rapier3d-compat-vendor-C_-nUdOh.js";import{e as d,r as l}from"./react-vendor-D8fagYP-.js";import{r as Re,I as vt,k as bt,E as ke,V as k,aI as ht,Q as He,s as Ct}from"./three-vendor-BlRjbAe-.js";import{u as xt}from"./use-asset-vendor-JkQW2fxr.js";import{u as Et,a as Ze}from"./react-three-fiber-vendor-YLb0z6Im.js";function St(e,t=1e-4){t=Math.max(t,Number.EPSILON);const o={},n=e.getIndex(),r=e.getAttribute("position"),i=n?n.count:r.count;let s=0;const a=Object.keys(e.attributes),h={},p={},x=[],y=["getX","getY","getZ","getW"];for(let C=0,g=a.length;C<g;C++){const u=a[C];h[u]=[];const f=e.morphAttributes[u];f&&(p[u]=new Array(f.length).fill(0).map(()=>[]))}const R=Math.log10(1/t),P=Math.pow(10,R);for(let C=0;C<i;C++){const g=n?n.getX(C):C;let u="";for(let f=0,E=a.length;f<E;f++){const D=a[f],b=e.getAttribute(D),w=b.itemSize;for(let G=0;G<w;G++)u+=`${~~(b[y[G]](g)*P)},`}if(u in o)x.push(o[u]);else{for(let f=0,E=a.length;f<E;f++){const D=a[f],b=e.getAttribute(D),w=e.morphAttributes[D],G=b.itemSize,Y=h[D],oe=p[D];for(let ee=0;ee<G;ee++){const M=y[ee];if(Y.push(b[M](g)),w)for(let te=0,Me=w.length;te<Me;te++)oe[te].push(w[te][M](g))}}o[u]=s,x.push(s),s++}}const B=e.clone();for(let C=0,g=a.length;C<g;C++){const u=a[C],f=e.getAttribute(u),E=new f.array.constructor(h[u]),D=new Re(E,f.itemSize,f.normalized);if(B.setAttribute(u,D),u in p)for(let b=0;b<p[u].length;b++){const w=e.morphAttributes[u][b],G=new w.array.constructor(p[u][b]),Y=new Re(G,w.itemSize,w.normalized);B.morphAttributes[u][b]=Y}}return B.setIndex(x),B}function wt(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function Ke(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),o.push.apply(o,n)}return o}function v(e){for(var t=1;t<arguments.length;t++){var o=arguments[t]!=null?arguments[t]:{};t%2?Ke(Object(o),!0).forEach(function(n){wt(e,n,o[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):Ke(Object(o)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))})}return e}const Rt=new He;new ke;const Pt=new k;new vt;const X=new bt,O=new k,H=new He,$=new k,Mt=e=>{const[t,o,n]=e;return new k(t,o,n)},Xe=({x:e,y:t,z:o,w:n})=>Rt.set(e,t,o,n),Ft=e=>{if(Array.isArray(e))return new Le(e[0],e[1],e[2]);if(typeof e=="number")return new Le(e,e,e);{const t=e;return new Le(t.x,t.y,t.z)}},At={fixed:1,dynamic:0,kinematicPosition:2,kinematicVelocity:3},Je=e=>At[e],Ot=(e,t)=>{const o=Array.from(e);for(let n=0;n<e.length/3;n++)o[n*3]*=t.x,o[n*3+1]*=t.y,o[n*3+2]*=t.z;return o},_e=e=>e?e instanceof He?[e.x,e.y,e.z,e.w]:e instanceof k||e instanceof ke?[e.x,e.y,e.z]:Array.isArray(e)?e:[e]:[0];function K(e){const t=l.useRef();return t.current===void 0&&(t.current={value:typeof e=="function"?e():e}),t.current.value}const jt=e=>{const t=l.useRef(e),o=l.useRef(0),n=l.useRef(0);l.useEffect(()=>{t.current=e},[e]),l.useEffect(()=>{const r=()=>{const i=performance.now(),s=i-n.current;o.current=requestAnimationFrame(r),t.current(s/1e3),n.current=i};return o.current=requestAnimationFrame(r),()=>cancelAnimationFrame(o.current)},[])},It=({onStep:e,updatePriority:t})=>(Ze((o,n)=>{e(n)},t),null),Bt=({onStep:e})=>(jt(t=>{e(t)}),null),Dt=({onStep:e,type:t,updatePriority:o})=>t==="independent"?d.createElement(Bt,{onStep:e}):d.createElement(It,{onStep:e,updatePriority:o});var Tt=l.memo(Dt);function Wt(e,t){if(e==null)return{};var o={},n=Object.keys(e),r,i;for(i=0;i<n.length;i++)r=n[i],!(t.indexOf(r)>=0)&&(o[r]=e[r]);return o}function Ge(e,t){if(e==null)return{};var o=Wt(e,t),n,r;if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],!(t.indexOf(n)>=0)&&Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}const zt=["mass","linearDamping","angularDamping","type","onCollisionEnter","onCollisionExit","onIntersectionEnter","onIntersectionExit","onContactForce","children","canSleep","ccd","gravityScale"],Nt=(e,t,o)=>{const n=t.slice();if(e==="heightfield"){const i=n[3];return i.x*=o.x,i.x*=o.y,i.x*=o.z,n}if(e==="trimesh"||e==="convexHull")return n[0]=Ot(n[0],o),n;const r=[o.x,o.y,o.z,o.x,o.x];return n.map((i,s)=>r[s]*i)},Vt=(e,t,o,n)=>{const r=Nt(e.shape,e.args,o),i=pt[e.shape](...r);return t.createCollider(i,n==null?void 0:n())},qt=["shape","args"],Ye="Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.",Lt=(e,t)=>{if(t.density!==void 0){if(t.mass!==void 0||t.massProperties!==void 0)throw new Error(Ye);e.setDensity(t.density);return}if(t.mass!==void 0){if(t.massProperties!==void 0)throw new Error(Ye);e.setMass(t.mass);return}t.massProperties!==void 0&&e.setMassProperties(t.massProperties.mass,t.massProperties.centerOfMass,t.massProperties.principalAngularInertia,t.massProperties.angularInertiaLocalFrame)},$e={sensor:(e,t)=>{e.setSensor(t)},collisionGroups:(e,t)=>{e.setCollisionGroups(t)},solverGroups:(e,t)=>{e.setSolverGroups(t)},friction:(e,t)=>{e.setFriction(t)},frictionCombineRule:(e,t)=>{e.setFrictionCombineRule(t)},restitution:(e,t)=>{e.setRestitution(t)},restitutionCombineRule:(e,t)=>{e.setRestitutionCombineRule(t)},quaternion:()=>{},position:()=>{},rotation:()=>{},scale:()=>{}},et=Object.keys($e),kt=(e,t,o)=>{const n=o.get(e.handle);if(n){var r;const i=n.object.parent.getWorldScale(Pt),s=(r=n.worldParent)===null||r===void 0?void 0:r.matrixWorld.clone().invert();n.object.updateWorldMatrix(!0,!1),X.copy(n.object.matrixWorld),s&&X.premultiply(s),X.decompose(O,H,$),e.parent()?(e.setTranslationWrtParent({x:O.x*i.x,y:O.y*i.y,z:O.z*i.z}),e.setRotationWrtParent(H)):(e.setTranslation({x:O.x*i.x,y:O.y*i.y,z:O.z*i.z}),e.setRotation(H)),et.forEach(a=>{if(a in t){const h=t[a];$e[a](e,h,t)}}),Lt(e,t)}},Ht=(e,t,o)=>{const n=l.useMemo(()=>et.flatMap(r=>_e(t[r])),[t]);l.useEffect(()=>{const r=e();kt(r,t,o)},[...n,e])},Gt=e=>{let t=!1;return e.traverseAncestors(o=>{o.userData.r3RapierType==="MeshCollider"&&(t=!0)}),t},Qt=(e,t,o)=>({collider:e,worldParent:o||void 0,object:t}),Ut={cuboid:"cuboid",ball:"ball",hull:"convexHull",trimesh:"trimesh"},Kt=({object:e,ignoreMeshColliders:t=!0,options:o})=>{const n=[];e.updateWorldMatrix(!0,!1);const r=e.matrixWorld.clone().invert(),i=s=>{if("isMesh"in s){if(t&&Gt(s))return;const a=s.getWorldScale($),h=Ut[o.colliders||"cuboid"];s.updateWorldMatrix(!0,!1),X.copy(s.matrixWorld).premultiply(r).decompose(O,H,$);const p=new ke().setFromQuaternion(H,"XYZ"),{geometry:x}=s,{args:y,offset:R}=Xt(x,o.colliders||"cuboid"),P=v(v({},nt(o)),{},{args:y,shape:h,rotation:[p.x,p.y,p.z],position:[O.x+R.x*a.x,O.y+R.y*a.y,O.z+R.z*a.z],scale:[a.x,a.y,a.z]});n.push(P)}};return o.includeInvisible?e.traverse(i):e.traverseVisible(i),n},Xt=(e,t)=>{switch(t){case"cuboid":{e.computeBoundingBox();const{boundingBox:n}=e,r=n.getSize(new k);return{args:[r.x/2,r.y/2,r.z/2],offset:n.getCenter(new k)}}case"ball":{e.computeBoundingSphere();const{boundingSphere:n}=e;return{args:[n.radius],offset:n.center}}case"trimesh":{var o;const n=e.index?e.clone():St(e);return{args:[n.attributes.position.array,(o=n.index)===null||o===void 0?void 0:o.array],offset:new k}}case"hull":return{args:[e.clone().attributes.position.array],offset:new k}}return{args:[],offset:new k}},tt=e=>({collision:!!(e!=null&&e.onCollisionEnter||e!=null&&e.onCollisionExit||e!=null&&e.onIntersectionEnter||e!=null&&e.onIntersectionExit),contactForce:!!(e!=null&&e.onContactForce)}),Yt=(e,t,o,n={})=>{const{onCollisionEnter:r,onCollisionExit:i,onIntersectionEnter:s,onIntersectionExit:a,onContactForce:h}=t;l.useEffect(()=>{const p=e();if(p){const{collision:x,contactForce:y}=tt(t),R=x||n.collision,P=y||n.contactForce;R&&P?p.setActiveEvents(Se.COLLISION_EVENTS|Se.CONTACT_FORCE_EVENTS):R?p.setActiveEvents(Se.COLLISION_EVENTS):P&&p.setActiveEvents(Se.CONTACT_FORCE_EVENTS),o.set(p.handle,{onCollisionEnter:r,onCollisionExit:i,onIntersectionEnter:s,onIntersectionExit:a,onContactForce:h})}return()=>{p&&o.delete(p.handle)}},[r,i,s,a,h,n])},nt=(e={})=>Ge(e,zt),Pe=()=>{const e=l.useContext(ot);if(!e)throw new Error("react-three-rapier: useRapier must be used within <Physics />!");return e},Qe=(e,t,o=!0)=>{const[n,r]=l.useState([]);return l.useEffect(()=>{e.current&&t.colliders!==!1&&r(Kt({object:e.current,options:t,ignoreMeshColliders:o}))},[t.colliders]),n},Zt=l.memo(()=>{const{world:e}=Pe(),t=l.useRef(null);return Ze(()=>{const o=t.current;if(!o)return;const n=e.debugRender();o.geometry.setAttribute("position",new Re(n.vertices,3)),o.geometry.setAttribute("color",new Re(n.colors,4))}),d.createElement("group",null,d.createElement("lineSegments",{ref:t,frustumCulled:!1},d.createElement("lineBasicMaterial",{color:16777215,vertexColors:!0}),d.createElement("bufferGeometry",null)))}),Jt=e=>{let t;const o={get(s,a){return t||(t=e()),Reflect.get(t,a)},set(s,a,h){return t||(t=e()),Reflect.set(t,a,h)}};return{proxy:new Proxy({},o),reset:()=>{t=void 0},set:s=>{t=s}}},ot=l.createContext(void 0),we=(e,t)=>{var o,n,r,i,s,a;return{target:{rigidBody:e.rigidBody.object,collider:e.collider.object,colliderObject:(o=e.collider.state)===null||o===void 0?void 0:o.object,rigidBodyObject:(n=e.rigidBody.state)===null||n===void 0?void 0:n.object},other:{rigidBody:t.rigidBody.object,collider:t.collider.object,colliderObject:(r=t.collider.state)===null||r===void 0?void 0:r.object,rigidBodyObject:(i=t.rigidBody.state)===null||i===void 0?void 0:i.object},rigidBody:t.rigidBody.object,collider:t.collider.object,colliderObject:(s=t.collider.state)===null||s===void 0?void 0:s.object,rigidBodyObject:(a=t.rigidBody.state)===null||a===void 0?void 0:a.object}},_t=async()=>{let e=await mt(()=>import("./dimforge-rapier3d-compat-vendor-C_-nUdOh.js"),[]);return await e.init(),e},Pn=e=>{const{colliders:t="cuboid",children:o,timeStep:n=1/60,paused:r=!1,interpolate:i=!0,updatePriority:s,updateLoop:a="follow",debug:h=!1,gravity:p=[0,-9.81,0],allowedLinearError:x=.001,predictionDistance:y=.002,numSolverIterations:R=4,numAdditionalFrictionIterations:P=4,numInternalPgsIterations:B=1,minIslandSize:C=128,maxCcdSubsteps:g=1,erp:u=.8}=e,f=xt(_t),{invalidate:E}=Et(),D=K(()=>new Map),b=K(()=>new Map),w=K(()=>new Map),G=K(()=>new Map),Y=K(()=>new yt(!1)),oe=K(()=>new Set),ee=K(()=>new Set),{proxy:M,reset:te,set:Me}=K(()=>Jt(()=>new f.World(Mt(p))));l.useEffect(()=>()=>{M.free(),te()},[]),l.useEffect(()=>{M.gravity=Ft(p),M.integrationParameters.numSolverIterations=R,M.integrationParameters.numAdditionalFrictionIterations=P,M.integrationParameters.numInternalPgsIterations=B,M.integrationParameters.allowedLinearError=x,M.integrationParameters.minIslandSize=C,M.integrationParameters.maxCcdSubsteps=g,M.integrationParameters.predictionDistance=y,M.integrationParameters.erp=u},[M,...p,R,P,B,x,C,g,y,u]);const re=l.useCallback(Q=>{var W;const J=M.getCollider(Q),le=G.get(Q),se=b.get(Q),U=J==null||(W=J.parent())===null||W===void 0?void 0:W.handle,c=U!==void 0?M.getRigidBody(U):void 0,j=c&&U!==void 0?w.get(U):void 0,I=U!==void 0?D.get(U):void 0;return{collider:{object:J,events:le,state:se},rigidBody:{object:c,events:j,state:I}}},[]),[Z]=l.useState({previousState:{},accumulator:0}),ie=l.useCallback(Q=>{const W=M,J=n==="vary",le=Ct.clamp(Q,0,.5),se=c=>{oe.forEach(j=>{j.current(W)}),W.timestep=c,W.step(Y),ee.forEach(j=>{j.current(W)})};if(J)se(le);else for(Z.accumulator+=le;Z.accumulator>=n;)i&&(Z.previousState={},W.forEachRigidBody(c=>{Z.previousState[c.handle]={position:c.translation(),rotation:c.rotation()}})),se(n),Z.accumulator-=n;const U=J||!i||r?1:Z.accumulator/n;D.forEach((c,j)=>{const I=W.getRigidBody(j),m=w.get(j);if(m!=null&&m.onSleep||m!=null&&m.onWake){if(I.isSleeping()&&!c.isSleeping){var S;m==null||(S=m.onSleep)===null||S===void 0||S.call(m)}if(!I.isSleeping()&&c.isSleeping){var A;m==null||(A=m.onWake)===null||A===void 0||A.call(m)}c.isSleeping=I.isSleeping()}if(!I||I.isSleeping()&&!("isInstancedMesh"in c.object)||!c.setMatrix)return;let T=I.translation(),V=I.rotation(),q=Z.previousState[j];q&&(X.compose(q.position,Xe(q.rotation),c.scale).premultiply(c.invertedWorldMatrix).decompose(O,H,$),c.meshType=="mesh"&&(c.object.position.copy(O),c.object.quaternion.copy(H))),X.compose(T,Xe(V),c.scale).premultiply(c.invertedWorldMatrix).decompose(O,H,$),c.meshType=="instancedMesh"?c.setMatrix(X):(c.object.position.lerp(O,U),c.object.quaternion.slerp(H,U))}),Y.drainCollisionEvents((c,j,I)=>{const m=re(c),S=re(j);if(!(m!=null&&m.collider.object)||!(S!=null&&S.collider.object))return;const A=we(m,S),T=we(S,m);if(I)W.contactPair(m.collider.object,S.collider.object,(ve,be)=>{var he,ze,Ce,Ne,xe,Ve,Ee,qe;(he=m.rigidBody.events)===null||he===void 0||(ze=he.onCollisionEnter)===null||ze===void 0||ze.call(he,v(v({},A),{},{manifold:ve,flipped:be})),(Ce=S.rigidBody.events)===null||Ce===void 0||(Ne=Ce.onCollisionEnter)===null||Ne===void 0||Ne.call(Ce,v(v({},T),{},{manifold:ve,flipped:be})),(xe=m.collider.events)===null||xe===void 0||(Ve=xe.onCollisionEnter)===null||Ve===void 0||Ve.call(xe,v(v({},A),{},{manifold:ve,flipped:be})),(Ee=S.collider.events)===null||Ee===void 0||(qe=Ee.onCollisionEnter)===null||qe===void 0||qe.call(Ee,v(v({},T),{},{manifold:ve,flipped:be}))});else{var V,q,N,L,_,ne,ae,Fe;(V=m.rigidBody.events)===null||V===void 0||(q=V.onCollisionExit)===null||q===void 0||q.call(V,A),(N=S.rigidBody.events)===null||N===void 0||(L=N.onCollisionExit)===null||L===void 0||L.call(N,T),(_=m.collider.events)===null||_===void 0||(ne=_.onCollisionExit)===null||ne===void 0||ne.call(_,A),(ae=S.collider.events)===null||ae===void 0||(Fe=ae.onCollisionExit)===null||Fe===void 0||Fe.call(ae,T)}if(I){if(W.intersectionPair(m.collider.object,S.collider.object)){var ce,Ae,de,Oe,ue,je,fe,Ie;(ce=m.rigidBody.events)===null||ce===void 0||(Ae=ce.onIntersectionEnter)===null||Ae===void 0||Ae.call(ce,A),(de=S.rigidBody.events)===null||de===void 0||(Oe=de.onIntersectionEnter)===null||Oe===void 0||Oe.call(de,T),(ue=m.collider.events)===null||ue===void 0||(je=ue.onIntersectionEnter)===null||je===void 0||je.call(ue,A),(fe=S.collider.events)===null||fe===void 0||(Ie=fe.onIntersectionEnter)===null||Ie===void 0||Ie.call(fe,T)}}else{var me,Be,pe,De,ge,Te,ye,We;(me=m.rigidBody.events)===null||me===void 0||(Be=me.onIntersectionExit)===null||Be===void 0||Be.call(me,A),(pe=S.rigidBody.events)===null||pe===void 0||(De=pe.onIntersectionExit)===null||De===void 0||De.call(pe,T),(ge=m.collider.events)===null||ge===void 0||(Te=ge.onIntersectionExit)===null||Te===void 0||Te.call(ge,A),(ye=S.collider.events)===null||ye===void 0||(We=ye.onIntersectionExit)===null||We===void 0||We.call(ye,T)}}),Y.drainContactForceEvents(c=>{var j,I,m,S,A,T,V,q;const N=re(c.collider1()),L=re(c.collider2());if(!(N!=null&&N.collider.object)||!(L!=null&&L.collider.object))return;const _=we(N,L),ne=we(L,N);(j=N.rigidBody.events)===null||j===void 0||(I=j.onContactForce)===null||I===void 0||I.call(j,v(v({},_),{},{totalForce:c.totalForce(),totalForceMagnitude:c.totalForceMagnitude(),maxForceDirection:c.maxForceDirection(),maxForceMagnitude:c.maxForceMagnitude()})),(m=L.rigidBody.events)===null||m===void 0||(S=m.onContactForce)===null||S===void 0||S.call(m,v(v({},ne),{},{totalForce:c.totalForce(),totalForceMagnitude:c.totalForceMagnitude(),maxForceDirection:c.maxForceDirection(),maxForceMagnitude:c.maxForceMagnitude()})),(A=N.collider.events)===null||A===void 0||(T=A.onContactForce)===null||T===void 0||T.call(A,v(v({},_),{},{totalForce:c.totalForce(),totalForceMagnitude:c.totalForceMagnitude(),maxForceDirection:c.maxForceDirection(),maxForceMagnitude:c.maxForceMagnitude()})),(V=L.collider.events)===null||V===void 0||(q=V.onContactForce)===null||q===void 0||q.call(V,v(v({},ne),{},{totalForce:c.totalForce(),totalForceMagnitude:c.totalForceMagnitude(),maxForceDirection:c.maxForceDirection(),maxForceMagnitude:c.maxForceMagnitude()}))}),W.forEachActiveRigidBody(()=>{E()})},[r,n,i,M]),ut=l.useMemo(()=>({rapier:f,world:M,setWorld:Q=>{Me(Q)},physicsOptions:{colliders:t,gravity:p},rigidBodyStates:D,colliderStates:b,rigidBodyEvents:w,colliderEvents:G,beforeStepCallbacks:oe,afterStepCallbacks:ee,isPaused:r,isDebug:h,step:ie}),[r,ie,h,t,p]),ft=l.useCallback(Q=>{r||ie(Q)},[r,ie]);return d.createElement(ot.Provider,{value:ut},d.createElement(Tt,{onStep:ft,type:a,updatePriority:s}),h&&d.createElement(Zt,null),o)};function F(){return F=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(e[n]=o[n])}return e},F.apply(this,arguments)}const rt=(e,t,o)=>{const n=l.useRef(),r=l.useCallback(()=>(n.current||(n.current=e()),n.current),o);return l.useEffect(()=>{const i=r(),s=()=>t(i);return()=>{s(),n.current=void 0}},[r]),r},$t=({x:e,y:t,z:o}={x:0,y:0,z:0})=>new k(e,t,o),Ue=(e,t=null)=>{const o=l.useRef(t);return e&&typeof e!="function"?(e.current||(e.current=o.current),e):o},z=l.memo(l.forwardRef((e,t)=>{const{children:o,position:n,rotation:r,quaternion:i,scale:s,name:a}=e,{world:h,colliderEvents:p,colliderStates:x}=Pe(),y=ct(),R=Ue(t),P=l.useRef(null),B=qt.flatMap(u=>Array.isArray(e[u])?[...e[u]]:e[u]),C=rt(()=>{const u=P.current.getWorldScale($t()),f=Vt(e,h,u,y==null?void 0:y.getRigidBody);return typeof t=="function"&&t(f),R.current=f,f},u=>{h.getCollider(u.handle)&&h.removeCollider(u,!0)},[...B,y]);l.useEffect(()=>{const u=C();return x.set(u.handle,Qt(u,P.current,y==null?void 0:y.ref.current)),()=>{x.delete(u.handle)}},[C]);const g=l.useMemo(()=>v(v({},nt(y==null?void 0:y.options)),e),[e,y==null?void 0:y.options]);return Ht(C,g,x),Yt(C,g,p,tt(y==null?void 0:y.options)),d.createElement("object3D",{position:n,rotation:r,quaternion:i,scale:s,ref:P,name:a},o)})),en=d.forwardRef((e,t)=>d.createElement(z,F({},e,{shape:"cuboid",ref:t})));en.displayName="CuboidCollider";const tn=d.forwardRef((e,t)=>d.createElement(z,F({},e,{shape:"roundCuboid",ref:t})));tn.displayName="RoundCuboidCollider";const nn=d.forwardRef((e,t)=>d.createElement(z,F({},e,{shape:"ball",ref:t})));nn.displayName="BallCollider";const on=d.forwardRef((e,t)=>d.createElement(z,F({},e,{shape:"capsule",ref:t})));on.displayName="CapsuleCollider";const rn=d.forwardRef((e,t)=>d.createElement(z,F({},e,{shape:"heightfield",ref:t})));rn.displayName="HeightfieldCollider";const ln=d.forwardRef((e,t)=>d.createElement(z,F({},e,{shape:"trimesh",ref:t})));ln.displayName="TrimeshCollider";const sn=d.forwardRef((e,t)=>d.createElement(z,F({},e,{shape:"cone",ref:t})));sn.displayName="ConeCollider";const an=d.forwardRef((e,t)=>d.createElement(z,F({},e,{shape:"roundCone",ref:t})));an.displayName="RoundConeCollider";const it=d.forwardRef((e,t)=>d.createElement(z,F({},e,{shape:"cylinder",ref:t})));it.displayName="CylinderCollider";it.displayName="RoundCylinderCollider";const cn=d.forwardRef((e,t)=>d.createElement(z,F({},e,{shape:"convexHull",ref:t})));cn.displayName="ConvexHullCollider";const dn=e=>{var t;const o=Je((e==null?void 0:e.type)||"dynamic"),n=new gt(o);return n.canSleep=(t=e==null?void 0:e.canSleep)!==null&&t!==void 0?t:!0,n},un=({rigidBody:e,object:t,setMatrix:o,getMatrix:n,worldScale:r,meshType:i="mesh"})=>{t.updateWorldMatrix(!0,!1);const s=t.parent.matrixWorld.clone().invert();return{object:t,rigidBody:e,invertedWorldMatrix:s,setMatrix:o||(a=>{t.matrix.copy(a)}),getMatrix:n||(a=>a.copy(t.matrix)),scale:r||t.getWorldScale($).clone(),isSleeping:!1,meshType:i}},fn=["args","colliders","canSleep"],lt={gravityScale:(e,t)=>{e.setGravityScale(t,!0)},additionalSolverIterations(e,t){e.setAdditionalSolverIterations(t)},linearDamping:(e,t)=>{e.setLinearDamping(t)},angularDamping:(e,t)=>{e.setAngularDamping(t)},dominanceGroup:(e,t)=>{e.setDominanceGroup(t)},enabledRotations:(e,[t,o,n])=>{e.setEnabledRotations(t,o,n,!0)},enabledTranslations:(e,[t,o,n])=>{e.setEnabledTranslations(t,o,n,!0)},lockRotations:(e,t)=>{e.lockRotations(t,!0)},lockTranslations:(e,t)=>{e.lockTranslations(t,!0)},angularVelocity:(e,[t,o,n])=>{e.setAngvel({x:t,y:o,z:n},!0)},linearVelocity:(e,[t,o,n])=>{e.setLinvel({x:t,y:o,z:n},!0)},ccd:(e,t)=>{e.enableCcd(t)},userData:(e,t)=>{e.userData=t},type(e,t){e.setBodyType(Je(t),!0)},position:()=>{},rotation:()=>{},quaternion:()=>{},scale:()=>{}},st=Object.keys(lt),mn=(e,t,o,n=!0)=>{if(!e)return;const r=o.get(e.handle);r&&(n&&(r.object.updateWorldMatrix(!0,!1),X.copy(r.object.matrixWorld).decompose(O,H,$),e.setTranslation(O,!1),e.setRotation(H,!1)),st.forEach(i=>{i in t&&lt[i](e,t[i])}))},pn=(e,t,o,n=!0)=>{const r=l.useMemo(()=>st.flatMap(i=>_e(t[i])),[t]);l.useEffect(()=>{const i=e();mn(i,t,o,n)},r)},gn=(e,t,o)=>{const{onWake:n,onSleep:r,onCollisionEnter:i,onCollisionExit:s,onIntersectionEnter:a,onIntersectionExit:h,onContactForce:p}=t,x={onWake:n,onSleep:r,onCollisionEnter:i,onCollisionExit:s,onIntersectionEnter:a,onIntersectionExit:h,onContactForce:p};l.useEffect(()=>{const y=e();return o.set(y.handle,x),()=>{o.delete(y.handle)}},[n,r,i,s,a,h,p])},yn=["children","type","position","rotation","scale","quaternion","transformState"],at=l.createContext(void 0),ct=()=>l.useContext(at),dt=l.memo(l.forwardRef((e,t)=>{const{children:o,type:n,position:r,rotation:i,scale:s,quaternion:a,transformState:h}=e,p=Ge(e,yn),x=l.useRef(null),y=Ue(t),{world:R,rigidBodyStates:P,physicsOptions:B,rigidBodyEvents:C}=Pe(),g=l.useMemo(()=>v(v(v({},B),e),{},{children:void 0}),[B,e]),u=fn.flatMap(b=>Array.isArray(g[b])?[...g[b]]:g[b]),f=Qe(x,g),E=rt(()=>{const b=dn(g),w=R.createRigidBody(b);return typeof t=="function"&&t(w),y.current=w,w},b=>{R.getRigidBody(b.handle)&&R.removeRigidBody(b)},u);l.useEffect(()=>{const b=E(),w=un({rigidBody:b,object:x.current});return P.set(b.handle,e.transformState?e.transformState(w):w),()=>{P.delete(b.handle)}},[E]),pn(E,g,P),gn(E,g,C);const D=l.useMemo(()=>({ref:x,getRigidBody:E,options:g}),[E]);return d.createElement(at.Provider,{value:D},d.createElement("object3D",F({ref:x},p,{position:r,rotation:i,quaternion:a,scale:s}),o,f.map((b,w)=>d.createElement(z,F({key:w},b)))))}));dt.displayName="RigidBody";const vn=l.memo(e=>{const{children:t,type:o}=e,{physicsOptions:n}=Pe(),r=l.useRef(null),{options:i}=ct(),s=l.useMemo(()=>v(v(v({},n),i),{},{children:void 0,colliders:o}),[n,i]),a=Qe(r,s,!1);return d.createElement("object3D",{ref:r,userData:{r3RapierType:"MeshCollider"}},t,a.map((h,p)=>d.createElement(z,F({key:p},h))))});vn.displayName="MeshCollider";const bn=["children","instances","colliderNodes","position","rotation","quaternion","scale"],hn=l.memo(l.forwardRef((e,t)=>{const o=Ue(t,[]),n=l.useRef(null),r=l.useRef(null),{children:i,instances:s,colliderNodes:a=[],position:h,rotation:p,quaternion:x,scale:y}=e,R=Ge(e,bn),P=Qe(n,v(v({},e),{},{children:void 0})),B=()=>{const g=r.current.children[0];if(g&&"isInstancedMesh"in g)return g};l.useEffect(()=>{const g=B();g?g.instanceMatrix.setUsage(ht):console.warn("InstancedRigidBodies expects exactly one child, which must be an InstancedMesh")},[]);const C=(g,u)=>{const f=B();return f?v(v({},g),{},{getMatrix:E=>(f.getMatrixAt(u,E),E),setMatrix:E=>{f.setMatrixAt(u,E),f.instanceMatrix.needsUpdate=!0},meshType:"instancedMesh"}):g};return d.createElement("object3D",F({ref:n},R,{position:h,rotation:p,quaternion:x,scale:y}),d.createElement("object3D",{ref:r},i),s==null?void 0:s.map((g,u)=>d.createElement(dt,F({},R,g,{ref:f=>o.current[u]=f,transformState:f=>C(f,u)}),d.createElement(d.Fragment,null,a.map((f,E)=>d.createElement(l.Fragment,{key:E},f)),P.map((f,E)=>d.createElement(z,F({key:E},f)))))))}));hn.displayName="InstancedRigidBodies";export{nn as B,it as C,Pn as P,dt as R};
